# Phase 83: GitHub Sync & Vercel Live Integration

**Status**: üü° Spec Ready - Ready for Implementation
**Date**: 2025-11-18
**Goal**: GitHub Repository Sync + Branch/PR Flow + Vercel Auto-Deploy Integration

## üéØ Overview

After completing Phase 82, F0 now has:
- ‚úÖ Complete VFS (Virtual File System)
- ‚úÖ Patch Engine + Recovery + History
- ‚úÖ GitHub repo + Vercel deployment setup

**Phase 83 Goal**: Connect F0 ‚Üî GitHub ‚Üî Vercel so that:

1. Patches generated by the Agent can be:
   - Applied to VFS (already done in Phase 82)
   - Applied to real GitHub branches
   - Converted to Commits + Pull Requests
   - Automatically deployed by Vercel as Preview Deployments

2. F0 becomes not just "AI managing files in VFS", but:
   - **AI making real Commits**
   - **AI creating Branches**
   - **AI opening Pull Requests**

This transforms F0 into a **true AI GitOps Platform**.

---

## üß± High-Level Architecture

### New Entities

#### 1. GitHub Repository Link

Each F0 project can be linked to one GitHub repository:

```typescript
projects/{projectId}/github: {
  provider: 'github',
  owner: string,              // e.g. "mbendary2019"
  repo: string,               // e.g. "F0"
  defaultBranch: string,      // e.g. "main"
  installationId?: string,    // For GitHub App
  linkedAt: Timestamp,
  linkedBy: uid,
  lastSyncedBranch?: string,  // "main"
  lastSyncedAt?: Timestamp,
  vercelProjectId?: string,   // Optional: for Vercel integration
  lastPreviewUrl?: string     // Optional: latest Vercel preview URL
}
```

#### 2. Git Branch Mapping

F0 can create branches for each Feature/Patch:

```typescript
projects/{projectId}/branches/{branchId}: {
  name: string,                // "f0/patch-123-auth-fix"
  fromBranch: string,          // "main"
  lastSyncedAt: Timestamp,
  createdBy: uid | 'agent',
  status: 'active' | 'merged' | 'stale'
}
```

#### 3. Patch ‚Üî Git Commit Mapping

Extend existing patch documents:

```typescript
projects/{projectId}/patches/{patchId}: {
  // Existing fields from Phase 82...

  // NEW: GitHub integration
  github: {
    branch: string | null,           // "f0/patch-xyz789-auth-fix"
    commitSha: string | null,        // "abc123def..."
    pullRequestNumber: number | null, // 42
    pullRequestUrl: string | null,   // "https://github.com/..."
    status: 'not_applied' | 'applied_to_branch' | 'pr_opened' | 'merged' | 'failed'
  }
}
```

---

## üìã Implementation Tasks

### 1) GitHub Linking (Backend)

**Goal**: Enable linking an F0 project to one GitHub repository.

#### 1.1 Cloud Function: `linkGithubRepo`

**File**: `functions/src/integrations/github/linkRepo.ts`

**Responsibilities**:
- Verify user permissions (project owner or admin)
- Validate GitHub repo exists (owner/repo)
- Store link data in Firestore
- (Later) Use GitHub App / OAuth

**Input**:
```typescript
{
  projectId: string;
  owner: string;       // "mbendary2019"
  repo: string;        // "F0"
  defaultBranch: string; // "main"
}
```

**Output**:
```typescript
{
  ok: boolean;
  message?: string;
}
```

**Implementation**:
```typescript
export const linkGithubRepo = onCall<LinkGithubRepoInput>(async (request) => {
  const { projectId, owner, repo, defaultBranch } = request.data;
  const uid = request.auth?.uid;

  if (!uid) {
    throw new HttpsError('unauthenticated', 'User must be authenticated');
  }

  // 1. Verify project ownership
  const projectRef = db.doc(`projects/${projectId}`);
  const projectDoc = await projectRef.get();

  if (!projectDoc.exists || projectDoc.data()?.createdBy !== uid) {
    throw new HttpsError('permission-denied', 'Not project owner');
  }

  // 2. Validate GitHub repo exists (via Octokit)
  const octokit = getOctokit(); // Helper to get authenticated client
  try {
    await octokit.repos.get({ owner, repo });
  } catch (error) {
    throw new HttpsError('not-found', `GitHub repo ${owner}/${repo} not found`);
  }

  // 3. Store link
  const githubRef = db.doc(`projects/${projectId}/github`);
  await githubRef.set({
    provider: 'github',
    owner,
    repo,
    defaultBranch,
    linkedAt: FieldValue.serverTimestamp(),
    linkedBy: uid
  });

  return { ok: true };
});
```

#### 1.2 UI Integration

**Location**: Project Settings page or Integrations tab

**UI Elements**:
```tsx
<Card>
  <CardHeader>
    <CardTitle>GitHub Repository</CardTitle>
  </CardHeader>
  <CardContent>
    <Input label="Owner" value={owner} onChange={...} />
    <Input label="Repo" value={repo} onChange={...} />
    <Input label="Default Branch" value={defaultBranch} onChange={...} />
    <Button onClick={handleLinkRepo}>Link Repository</Button>

    {linked && (
      <div>
        <Badge>Linked</Badge>
        <p>Repo: {owner}/{repo}</p>
        <p>Default Branch: {defaultBranch}</p>
        <p>Linked at: {linkedAt}</p>
      </div>
    )}
  </CardContent>
</Card>
```

---

### 2) GitHub Service Layer (Functions)

**Goal**: Single layer responsible for all GitHub API interactions.

#### File: `functions/src/integrations/github/client.ts`

**Functions**:

```typescript
import { Octokit } from '@octokit/rest';

// Initialize Octokit with auth
export function getOctokit(installationId?: string): Octokit {
  // Use GitHub App installation token or PAT from env
  const token = process.env.GITHUB_TOKEN;
  return new Octokit({ auth: token });
}

// Get repository info
export async function getRepo(owner: string, repo: string) {
  const octokit = getOctokit();
  const { data } = await octokit.repos.get({ owner, repo });
  return data;
}

// Get default branch
export async function getDefaultBranch(owner: string, repo: string): Promise<string> {
  const repoData = await getRepo(owner, repo);
  return repoData.default_branch;
}

// Create branch
export async function createBranch(
  owner: string,
  repo: string,
  fromBranch: string,
  newBranch: string
): Promise<string> {
  const octokit = getOctokit();

  // Get ref of source branch
  const { data: refData } = await octokit.git.getRef({
    owner,
    repo,
    ref: `heads/${fromBranch}`
  });

  // Create new branch
  await octokit.git.createRef({
    owner,
    repo,
    ref: `refs/heads/${newBranch}`,
    sha: refData.object.sha
  });

  return refData.object.sha;
}

// Get file content
export async function getFile(
  owner: string,
  repo: string,
  path: string,
  ref: string = 'main'
): Promise<string | null> {
  const octokit = getOctokit();

  try {
    const { data } = await octokit.repos.getContent({
      owner,
      repo,
      path,
      ref
    });

    if ('content' in data) {
      return Buffer.from(data.content, 'base64').toString('utf-8');
    }
    return null;
  } catch (error) {
    if (error.status === 404) return null;
    throw error;
  }
}

// Update file (create or modify)
export async function updateFile(
  owner: string,
  repo: string,
  path: string,
  content: string,
  message: string,
  branch: string
): Promise<string> {
  const octokit = getOctokit();

  // Get current file SHA (if exists)
  let sha: string | undefined;
  try {
    const { data } = await octokit.repos.getContent({
      owner,
      repo,
      path,
      ref: branch
    });
    if ('sha' in data) sha = data.sha;
  } catch (error) {
    // File doesn't exist, will be created
  }

  // Create/update file
  const { data } = await octokit.repos.createOrUpdateFileContents({
    owner,
    repo,
    path,
    message,
    content: Buffer.from(content).toString('base64'),
    branch,
    sha
  });

  return data.commit.sha;
}

// Create Pull Request
export async function createPullRequest(
  owner: string,
  repo: string,
  title: string,
  head: string,
  base: string,
  body: string
): Promise<{ number: number; url: string }> {
  const octokit = getOctokit();

  const { data } = await octokit.pulls.create({
    owner,
    repo,
    title,
    head,
    base,
    body
  });

  return {
    number: data.number,
    url: data.html_url
  };
}
```

---

### 3) Sync: GitHub ‚Üí VFS (Import)

**Goal**: Sync content from GitHub branch to VFS so Agent can work on a copy of the code.

#### 3.1 Cloud Function: `syncFromGithubToVfs`

**File**: `functions/src/integrations/github/syncToVfs.ts`

**Input**:
```typescript
{
  projectId: string;
  branch?: string; // defaults to defaultBranch
}
```

**Implementation**:
```typescript
export const syncFromGithubToVfs = onCall(async (request) => {
  const { projectId, branch } = request.data;
  const uid = request.auth?.uid;

  // 1. Get GitHub link
  const githubRef = db.doc(`projects/${projectId}/github`);
  const githubDoc = await githubRef.get();

  if (!githubDoc.exists) {
    throw new HttpsError('not-found', 'GitHub not linked');
  }

  const { owner, repo, defaultBranch } = githubDoc.data();
  const targetBranch = branch || defaultBranch;

  // 2. Get file tree from GitHub
  const octokit = getOctokit();
  const { data: tree } = await octokit.git.getTree({
    owner,
    repo,
    tree_sha: targetBranch,
    recursive: 'true'
  });

  // 3. Filter files (only src/, app/, etc.)
  const filesToSync = tree.tree.filter(item =>
    item.type === 'blob' &&
    (item.path?.startsWith('src/') ||
     item.path?.startsWith('app/') ||
     item.path?.startsWith('functions/'))
  );

  // 4. Sync each file to VFS
  for (const file of filesToSync) {
    if (!file.path) continue;

    const content = await getFile(owner, repo, file.path, targetBranch);
    if (content) {
      await writeFileToVfs(projectId, file.path, content, 'github-sync');
    }
  }

  // 5. Update last sync info
  await githubRef.update({
    lastSyncedBranch: targetBranch,
    lastSyncedAt: FieldValue.serverTimestamp()
  });

  return {
    ok: true,
    filesSynced: filesToSync.length,
    branch: targetBranch
  };
});
```

#### 3.2 UI

**Location**: GitHub Integration section in Project Settings

```tsx
<Card>
  <CardHeader>
    <CardTitle>Sync from GitHub</CardTitle>
  </CardHeader>
  <CardContent>
    <Button onClick={handleSyncFromGithub}>
      Sync from GitHub ‚Üí VFS
    </Button>

    {lastSync && (
      <div className="mt-2 text-sm text-gray-600">
        Last sync: {formatDate(lastSync.syncedAt)}
        <br />
        Branch: {lastSync.branch}
        <br />
        Files: {lastSync.filesCount}
      </div>
    )}
  </CardContent>
</Card>
```

---

### 4) Sync: Patch ‚Üí GitHub Branch

**Goal**: When a patch is ready and applied to VFS, push it to:
- A new GitHub branch
- A commit
- A Pull Request

#### 4.1 Cloud Function: `applyPatchToGithubBranch`

**File**: `functions/src/integrations/github/applyPatch.ts`

**Input**:
```typescript
{
  projectId: string;
  patchId: string;
  targetBranch?: string;      // defaults to defaultBranch
  createNewBranch?: boolean;  // defaults to true
  branchName?: string;        // auto-generated if not provided
  openPullRequest?: boolean;  // defaults to true
}
```

**Implementation**:
```typescript
export const applyPatchToGithubBranch = onCall(async (request) => {
  const {
    projectId,
    patchId,
    targetBranch,
    createNewBranch = true,
    branchName,
    openPullRequest = true
  } = request.data;

  // 1. Get GitHub info
  const githubRef = db.doc(`projects/${projectId}/github`);
  const githubDoc = await githubRef.get();

  if (!githubDoc.exists) {
    throw new HttpsError('not-found', 'GitHub not linked');
  }

  const { owner, repo, defaultBranch } = githubDoc.data();
  const baseBranch = targetBranch || defaultBranch;

  // 2. Get patch
  const patchRef = db.doc(`projects/${projectId}/patches/${patchId}`);
  const patchDoc = await patchRef.get();

  if (!patchDoc.exists) {
    throw new HttpsError('not-found', 'Patch not found');
  }

  const patchData = patchDoc.data();
  const patches = patchData.patches || [];

  // 3. Determine branch name
  let workingBranch = baseBranch;
  let commitSha: string | undefined;

  if (createNewBranch) {
    workingBranch = branchName || `f0/patch-${patchId}`;
    commitSha = await createBranch(owner, repo, baseBranch, workingBranch);
  }

  // 4. Apply each file change
  const filesModified: string[] = [];
  const filesCreated: string[] = [];
  const filesDeleted: string[] = [];

  for (const patch of patches) {
    const { filePath, isNew, isDeleted } = patch;

    try {
      if (isNew) {
        // Create new file
        const content = await readFileFromVfs(projectId, filePath);
        await updateFile(
          owner,
          repo,
          filePath,
          content || '',
          `Create ${filePath} (patch ${patchId})`,
          workingBranch
        );
        filesCreated.push(filePath);

      } else if (isDeleted) {
        // Delete file (via GitHub API)
        // Note: Implement deleteFile in client.ts
        filesDeleted.push(filePath);

      } else {
        // Update existing file
        const content = await readFileFromVfs(projectId, filePath);
        await updateFile(
          owner,
          repo,
          filePath,
          content || '',
          `Update ${filePath} (patch ${patchId})`,
          workingBranch
        );
        filesModified.push(filePath);
      }
    } catch (error) {
      console.error(`Failed to apply patch to ${filePath}:`, error);
    }
  }

  // 5. Create Pull Request
  let pullRequestNumber: number | undefined;
  let pullRequestUrl: string | undefined;

  if (openPullRequest && createNewBranch) {
    const prTitle = `F0 Patch: ${patchId}`;
    const prBody = `
## ü§ñ F0 Agent Patch

Patch ID: \`${patchId}\`
Attempts: ${patchData.attempts || 1}

### Files Changed
- Modified: ${filesModified.length}
- Created: ${filesCreated.length}
- Deleted: ${filesDeleted.length}

### Details
${filesModified.map(f => `- üìù ${f}`).join('\n')}
${filesCreated.map(f => `- ‚ú® ${f}`).join('\n')}
${filesDeleted.map(f => `- üóëÔ∏è ${f}`).join('\n')}

---
_Generated by F0 Agent_
    `.trim();

    const pr = await createPullRequest(
      owner,
      repo,
      prTitle,
      workingBranch,
      baseBranch,
      prBody
    );

    pullRequestNumber = pr.number;
    pullRequestUrl = pr.url;
  }

  // 6. Update patch document
  await patchRef.update({
    'github.branch': workingBranch,
    'github.commitSha': commitSha,
    'github.pullRequestNumber': pullRequestNumber,
    'github.pullRequestUrl': pullRequestUrl,
    'github.status': openPullRequest ? 'pr_opened' : 'applied_to_branch'
  });

  return {
    ok: true,
    branch: workingBranch,
    commitSha,
    pullRequestNumber,
    pullRequestUrl,
    filesModified,
    filesCreated,
    filesDeleted
  };
});
```

---

### 5) Frontend: "Apply Patch to GitHub" UI

#### 5.1 In PatchViewerModal / PatchMessage

Add a new section:

```tsx
{/* GitHub Actions */}
{patch.status === 'applied' && !patch.github?.status && (
  <div className="mt-4 border-t border-gray-700 pt-4">
    <h4 className="text-sm font-semibold mb-2">GitHub Actions</h4>

    <div className="space-y-2">
      <Select
        label="Base Branch"
        value={baseBranch}
        onChange={setBaseBranch}
        options={['main', 'develop']}
      />

      <Checkbox
        label="Create new branch"
        checked={createNewBranch}
        onChange={setCreateNewBranch}
      />

      {createNewBranch && (
        <Input
          label="Branch name (optional)"
          placeholder={`f0/patch-${patchId}`}
          value={branchName}
          onChange={setBranchName}
        />
      )}

      <Checkbox
        label="Open Pull Request"
        checked={openPR}
        onChange={setOpenPR}
      />

      <Button
        onClick={handleApplyToGithub}
        disabled={isApplyingToGithub}
      >
        {isApplyingToGithub ? 'Applying...' : 'Apply to GitHub'}
      </Button>
    </div>
  </div>
)}

{/* GitHub Status */}
{patch.github?.status && (
  <div className="mt-4 border-t border-gray-700 pt-4">
    <div className="flex items-center gap-2">
      <Badge variant={patch.github.status === 'pr_opened' ? 'success' : 'default'}>
        {patch.github.status}
      </Badge>

      {patch.github.pullRequestUrl && (
        <a
          href={patch.github.pullRequestUrl}
          target="_blank"
          rel="noopener noreferrer"
          className="text-blue-400 hover:underline text-sm"
        >
          View PR #{patch.github.pullRequestNumber}
        </a>
      )}
    </div>

    <div className="text-xs text-gray-400 mt-1">
      Branch: {patch.github.branch}
    </div>
  </div>
)}
```

#### Handler:
```typescript
const handleApplyToGithub = async () => {
  setIsApplyingToGithub(true);

  try {
    const applyPatchFn = httpsCallable(functions, 'applyPatchToGithubBranch');
    const result = await applyPatchFn({
      projectId,
      patchId,
      targetBranch: baseBranch,
      createNewBranch,
      branchName: branchName || undefined,
      openPullRequest: openPR
    });

    // Show success toast
    toast.success(
      `Branch created: ${result.data.branch}` +
      (result.data.pullRequestNumber
        ? `\nPR #${result.data.pullRequestNumber} opened`
        : '')
    );

  } catch (error) {
    console.error('Failed to apply patch to GitHub:', error);
    toast.error('Failed to apply patch to GitHub');
  } finally {
    setIsApplyingToGithub(false);
  }
};
```

---

### 6) Vercel Auto-Deploy Integration (Light)

Since the repo is already connected to Vercel:
- Any push to a new branch creates a **Deployment Preview**
- Preview URL: `https://f0-git-f0-patch-xyz789.vercel.app`

#### 6.1 Store Vercel Data (Optional)

You can add:

```typescript
projects/{projectId}/github: {
  vercelProjectId?: string,
  lastPreviewUrl?: string
}
```

For Phase 83, we'll assume:
- GitHub ‚Üî Vercel integration is already working
- F0 focuses on GitHub branches + PRs
- Vercel automatically deploys on branch push

In a later phase, you can:
- Fetch deployment URL from Vercel API
- Store it in patch document
- Display it in UI

---

### 7) UI Enhancements ‚Äî GitHub Status Blocks

#### 7.1 On Project Page

Add a card in Integrations section:

```tsx
<Card>
  <CardHeader>
    <CardTitle>GitHub Status</CardTitle>
  </CardHeader>
  <CardContent>
    {githubLinked ? (
      <>
        <div className="space-y-2 text-sm">
          <div className="flex justify-between">
            <span>Linked repo:</span>
            <span className="font-mono">{owner}/{repo}</span>
          </div>
          <div className="flex justify-between">
            <span>Default branch:</span>
            <span className="font-mono">{defaultBranch}</span>
          </div>
          <div className="flex justify-between">
            <span>Last synced:</span>
            <span>{formatDate(lastSyncedAt)}</span>
          </div>
        </div>

        <div className="flex gap-2 mt-4">
          <Button onClick={handleSyncFromGithub}>
            Sync from GitHub ‚Üí VFS
          </Button>
          <Button variant="outline" onClick={() => window.open(`https://github.com/${owner}/${repo}`)}>
            View on GitHub
          </Button>
        </div>
      </>
    ) : (
      <div>
        <p className="text-sm text-gray-600 mb-4">
          Link a GitHub repository to enable sync and PR features.
        </p>
        <Button onClick={() => setShowLinkDialog(true)}>
          Link GitHub Repository
        </Button>
      </div>
    )}
  </CardContent>
</Card>
```

#### 7.2 On Patches Page

For each patch in the table:

```tsx
<td>
  {patch.github?.status ? (
    <div className="space-y-1">
      <Badge variant={getStatusVariant(patch.github.status)}>
        {patch.github.status}
      </Badge>

      {patch.github.pullRequestNumber && (
        <a
          href={patch.github.pullRequestUrl}
          target="_blank"
          className="text-xs text-blue-400 hover:underline"
        >
          PR #{patch.github.pullRequestNumber}
        </a>
      )}
    </div>
  ) : (
    <Badge variant="secondary">Not synced</Badge>
  )}
</td>
```

---

### 8) Security & Permissions

#### Basic Rules:

1. **Only project owner/admins** can:
   - Link GitHub repo
   - Apply patch to GitHub
   - Open PRs

2. **Firestore Rules**:

```javascript
match /projects/{projectId}/github/{document=**} {
  allow read: if request.auth != null &&
              isProjectMember(projectId);
  allow write: if request.auth != null &&
               isProjectOwner(projectId);
}

match /projects/{projectId}/patches/{patchId} {
  // Allow reading github field
  allow read: if request.auth != null;

  // Prevent direct client writes to github field
  allow update: if request.auth != null &&
                !request.resource.data.keys().hasAny(['github']);
}
```

3. **GitHub Credentials**:

Use either:
- **GitHub App installation** (recommended)
- **PAT (Personal Access Token)** stored in Functions env

Store in `.secret.local`:
```bash
GITHUB_TOKEN=ghp_xxxxxxxxxxxxx
```

Or use GitHub App:
```bash
GITHUB_APP_ID=123456
GITHUB_APP_PRIVATE_KEY="-----BEGIN RSA PRIVATE KEY-----\n..."
```

---

### 9) Testing Plan

#### ‚úÖ Test 1: Link Repo

1. Navigate to Project Settings ‚Üí GitHub
2. Enter:
   - Owner: `mbendary2019`
   - Repo: `F0`
   - Default Branch: `main`
3. Click "Link Repository"
4. **Verify**:
   - Document written to `projects/{projectId}/github`
   - UI shows "Linked" badge
   - Shows repo info

#### ‚úÖ Test 2: Sync from GitHub ‚Üí VFS

1. Click "Sync from GitHub ‚Üí VFS"
2. **Verify**:
   - VFS contains files from GitHub repo
   - `lastSyncedAt` updated in Firestore
   - UI shows sync timestamp

#### ‚úÖ Test 3: Apply Patch to GitHub

1. Have a patch that's been applied to VFS
2. Open PatchViewerModal
3. Click "Apply to GitHub"
4. Select:
   - Base branch: `main`
   - Create new branch: ‚úì
   - Open Pull Request: ‚úì
5. **Verify in GitHub**:
   - New branch created (e.g., `f0/patch-xyz789`)
   - Files modified as per patch
   - PR opened with correct title/body
6. **Verify in Firestore**:
   - `patch.github.branch` set
   - `patch.github.pullRequestNumber` set
   - `patch.github.status` = `'pr_opened'`

#### ‚úÖ Test 4: UI Flow

1. From Patches page, click "View" on a patch
2. PatchViewerModal opens
3. Click "Apply to GitHub"
4. **Verify**:
   - Loading state shown
   - Success message displayed
   - "View PR" link appears
   - Clicking link opens GitHub PR

#### ‚úÖ Test 5: Vercel Preview

1. After PR is created, wait for Vercel deployment
2. **Verify**:
   - Vercel creates preview deployment
   - Preview URL accessible
   - Changes visible in preview

---

## ‚úÖ Phase 83 Outcome

After implementing Phase 83, F0 will be able to:

1. ‚úÖ Import code from GitHub ‚Üí VFS
2. ‚úÖ Generate patches via Agent
3. ‚úÖ Apply patches to VFS
4. ‚úÖ Apply patches to real GitHub branches
5. ‚úÖ Open Pull Requests
6. ‚úÖ Trigger Vercel auto-deploy for previews

This **officially elevates F0 to an AI GitOps Platform**:
- Not just a Code Assistant
- But a **GitHub-aware**, **Branch-aware**, **PR-aware** development platform

---

## üì¶ Files to Create/Modify

### New Files (Backend)

1. `functions/src/integrations/github/linkRepo.ts` - Link GitHub repo
2. `functions/src/integrations/github/client.ts` - GitHub API layer
3. `functions/src/integrations/github/syncToVfs.ts` - GitHub ‚Üí VFS sync
4. `functions/src/integrations/github/applyPatch.ts` - Patch ‚Üí GitHub
5. `functions/src/integrations/github/helpers.ts` - Shared utilities

### New Files (Frontend)

1. `src/lib/api/github.ts` - GitHub API client wrappers
2. `src/app/[locale]/projects/[id]/github/page.tsx` - GitHub settings page
3. `src/components/github/LinkRepoDialog.tsx` - Link repo dialog
4. `src/components/github/GitHubStatusCard.tsx` - Status card component

### Modified Files

1. `functions/src/index.ts` - Export new cloud functions
2. `src/features/agent/PatchMessage.tsx` - Add GitHub actions section
3. `src/components/PatchViewerModal.tsx` - Add GitHub actions
4. `src/app/[locale]/projects/[id]/patches/page.tsx` - Add GitHub status column
5. `firestore.rules` - Add rules for `/github` subcollection

---

## üöÄ Next Steps (After Phase 83)

### Phase 84: Advanced GitHub Features

- **Multiple repo support** - Link multiple repos per project
- **Branch protection** - Respect GitHub branch protection rules
- **Merge automation** - Auto-merge PRs after tests pass
- **Conflict resolution** - Handle merge conflicts intelligently

### Phase 85: Vercel Deep Integration

- **Deployment status tracking** - Show build status in F0
- **Preview URL display** - Show Vercel preview URLs inline
- **Deployment history** - List all deployments
- **Rollback support** - Rollback to previous deployments

### Phase 86: Multi-Platform Support

- **GitLab integration** - Support GitLab repos
- **Bitbucket integration** - Support Bitbucket repos
- **Self-hosted Git** - Support custom Git servers

---

## üìä Impact

### Before Phase 83:
- F0 = VFS-only code editing
- Patches applied to virtual files
- No real Git integration

### After Phase 83:
- F0 = **Full GitOps Platform**
- Patches ‚Üí Real Git commits
- Branches ‚Üí Real GitHub branches
- PRs ‚Üí Real Pull Requests
- Deploys ‚Üí Real Vercel previews

**This is a transformational upgrade** that puts F0 on par with:
- GitHub Copilot Workspace
- Cursor with Git integration
- Replit Deployments
- But with **full ownership** and **custom workflows**

---

**Status**: üü° Spec Ready
**Next**: Implementation
**Priority**: High
**Estimated Effort**: 3-5 days for core features
