// desktop/src/lib/atp/amtgEngine.ts
// Phase 140.3: Autonomous Missing Test Generator (AMTG) - Core Engine
// Generates safe, low-impact smoke test skeletons for high-risk untested files

import type {
  AMTGPolicy,
  AMTGResult,
  GeneratedTestSuggestion,
  TestFramework,
  DEFAULT_AMTG_POLICY,
} from './amtgTypes';
import type { CoverageDeltaSummary } from './coverageDeltaTypes';
import {
  AMTGCandidate,
  getCandidatesFromDelta,
  filterCandidatesByPolicy,
  hasExistingTests,
} from './amtgBridge';

/**
 * Generate a unique ID for a suggestion
 */
function generateSuggestionId(): string {
  return `amtg-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
}

/**
 * Extract a human-readable name from a file path
 */
function getFileDisplayName(filePath: string): string {
  const parts = filePath.split('/');
  const fileName = parts.pop() || '';
  return fileName.replace(/\.(ts|tsx|js|jsx)$/, '');
}

/**
 * Generate import statement based on test framework
 */
function generateImports(framework: TestFramework): string {
  switch (framework) {
    case 'vitest':
      return `import { describe, it, expect } from 'vitest';`;
    case 'jest':
      return `// Jest globals are available automatically`;
    case 'mocha':
      return `import { describe, it } from 'mocha';\nimport { expect } from 'chai';`;
    default:
      return `// Test framework imports`;
  }
}

/**
 * Generate a low-impact smoke test skeleton
 * This is a safe test that just verifies the module can be imported
 */
function generateLowImpactTest(
  candidate: AMTGCandidate,
): string {
  const displayName = getFileDisplayName(candidate.filePath);
  const imports = generateImports(candidate.framework);

  // Calculate relative import path
  // testFilePath: __tests__/foo/bar.test.ts
  // srcPath: src/foo/bar.ts
  // relative: ../../src/foo/bar
  const testParts = candidate.testFilePath.split('/');
  const srcParts = candidate.filePath.split('/');

  // Calculate depth of test file
  const testDepth = testParts.length - 1; // -1 for file name
  const upPath = '../'.repeat(testDepth);
  const relativePath = upPath + candidate.filePath.replace(/\.(ts|tsx|js|jsx)$/, '');

  return `${imports}

/**
 * Auto-generated smoke test for ${candidate.filePath}
 * Generated by AMTG (Autonomous Missing Test Generator)
 *
 * Risk Score: ${candidate.riskScore}/5
 * Coverage: ${candidate.coveragePct}%
 *
 * TODO: Add meaningful test cases for this module
 */

describe('${displayName}', () => {
  it('should be importable', async () => {
    // Smoke test: verify the module can be imported without errors
    const module = await import('${relativePath}');
    expect(module).toBeDefined();
  });

  it.todo('should have unit tests for core functionality');

  // TODO: Add more specific tests based on the module's exports
  // Examples:
  // - Test exported functions
  // - Test edge cases
  // - Test error handling
});
`;
}

/**
 * Generate a full test skeleton with more structure
 * Used when lowImpactOnly is false
 */
function generateFullTestSkeleton(
  candidate: AMTGCandidate,
): string {
  const displayName = getFileDisplayName(candidate.filePath);
  const imports = generateImports(candidate.framework);

  // Calculate relative import path
  const testParts = candidate.testFilePath.split('/');
  const testDepth = testParts.length - 1;
  const upPath = '../'.repeat(testDepth);
  const relativePath = upPath + candidate.filePath.replace(/\.(ts|tsx|js|jsx)$/, '');

  return `${imports}

/**
 * Test suite for ${candidate.filePath}
 * Generated by AMTG (Autonomous Missing Test Generator)
 *
 * Risk Score: ${candidate.riskScore}/5
 * Coverage: ${candidate.coveragePct}%
 */

// Import the module under test
import * as ${displayName}Module from '${relativePath}';

describe('${displayName}', () => {
  describe('Module Structure', () => {
    it('should be importable', () => {
      expect(${displayName}Module).toBeDefined();
    });

    it('should export expected members', () => {
      // TODO: Verify exports match expected API
      const exports = Object.keys(${displayName}Module);
      expect(exports.length).toBeGreaterThan(0);
    });
  });

  describe('Core Functionality', () => {
    it.todo('should handle normal input correctly');
    it.todo('should handle edge cases');
    it.todo('should handle errors gracefully');
  });

  describe('Integration', () => {
    it.todo('should work with dependencies');
    it.todo('should handle async operations');
  });
});
`;
}

/**
 * Generate a test suggestion for a candidate file
 */
function generateTestSuggestion(
  candidate: AMTGCandidate,
  lowImpactOnly: boolean,
): GeneratedTestSuggestion {
  const content = lowImpactOnly
    ? generateLowImpactTest(candidate)
    : generateFullTestSkeleton(candidate);

  const displayName = getFileDisplayName(candidate.filePath);

  return {
    id: generateSuggestionId(),
    filePath: candidate.filePath,
    testFilePath: candidate.testFilePath,
    framework: candidate.framework,
    title: `Add tests for ${displayName}`,
    description: `Auto-generated ${lowImpactOnly ? 'smoke' : 'full'} test skeleton for high-risk file (risk: ${candidate.riskScore}/5, coverage: ${candidate.coveragePct}%)`,
    content,
    source: 'autonomous',
    createdAt: Date.now(),
    riskScore: candidate.riskScore,
  };
}

/**
 * Main AMTG function: Generate missing tests for high-risk untested files
 *
 * @param deltaSummary - Coverage delta summary from the analysis step
 * @param policy - AMTG policy configuration
 * @returns AMTGResult with generated suggestions and skipped files
 */
export async function generateMissingTests(
  deltaSummary: CoverageDeltaSummary | undefined,
  policy: AMTGPolicy,
): Promise<AMTGResult> {
  // Early return if AMTG is disabled
  if (!policy.enabled) {
    return {
      suggestions: [],
      skipped: [],
      candidatesCount: 0,
    };
  }

  // Get candidates from coverage delta
  const allCandidates = getCandidatesFromDelta(deltaSummary);

  if (allCandidates.length === 0) {
    return {
      suggestions: [],
      skipped: [],
      candidatesCount: 0,
    };
  }

  // Apply policy filters
  const filteredCandidates = filterCandidatesByPolicy(allCandidates, {
    maxFiles: policy.maxFilesPerCycle,
    minRiskScore: policy.minRiskScore,
  });

  const suggestions: GeneratedTestSuggestion[] = [];
  const skipped: AMTGResult['skipped'] = [];

  // Process each candidate
  for (const candidate of allCandidates) {
    // Check if this candidate made it through filtering
    const isFiltered = filteredCandidates.some(
      (fc) => fc.filePath === candidate.filePath,
    );

    if (!isFiltered) {
      // Determine why it was filtered
      if (
        policy.minRiskScore !== undefined &&
        candidate.riskScore < policy.minRiskScore
      ) {
        skipped.push({ filePath: candidate.filePath, reason: 'low_risk' });
      } else {
        skipped.push({ filePath: candidate.filePath, reason: 'policy_limit' });
      }
      continue;
    }

    // Check for existing tests if policy requires
    if (policy.respectExistingTests) {
      const hasTests = await hasExistingTests(candidate.filePath);
      if (hasTests) {
        skipped.push({ filePath: candidate.filePath, reason: 'has_tests' });
        continue;
      }
    }

    // Generate the test suggestion
    const suggestion = generateTestSuggestion(candidate, policy.lowImpactOnly);
    suggestions.push(suggestion);
  }

  return {
    suggestions,
    skipped,
    candidatesCount: allCandidates.length,
  };
}

/**
 * Get a summary of AMTG results for logging
 */
export function getAMTGSummary(result: AMTGResult): string {
  const { suggestions, skipped, candidatesCount } = result;

  if (candidatesCount === 0) {
    return 'No untested high-risk files found';
  }

  const parts: string[] = [];

  if (suggestions.length > 0) {
    parts.push(`Generated ${suggestions.length} test suggestion(s)`);
  }

  if (skipped.length > 0) {
    const reasons = skipped.reduce(
      (acc, s) => {
        acc[s.reason] = (acc[s.reason] || 0) + 1;
        return acc;
      },
      {} as Record<string, number>,
    );

    const reasonStrs = Object.entries(reasons)
      .map(([reason, count]) => `${count} ${reason}`)
      .join(', ');

    parts.push(`Skipped: ${reasonStrs}`);
  }

  return parts.join(' | ') || `Processed ${candidatesCount} candidate(s)`;
}
